# 01 Linked List

순차 리스트: 배열을 기반으로 구현된 리스트

연결 리스트: 메모리의 동적할당을 기반으로 구현된 리스트

### 리스트 복사

|      | 코드                                                 | 설명                                              |
| ---- | ---------------------------------------------------- | ------------------------------------------------- |
| 1    | new_list = old_list                                  | 주소의 복사, 얕은 복사                            |
| 2    | new_list = old_list[:]                               | 슬라이싱, 깊은 복사                               |
| 3    | new_list = [] <br />new_list.extend(old_list)        | extend() : 리스트를 추가하는 함수, 깊은 복사      |
| 4    | new_list = list(old_list)                            | list(), 깊은 복사                                 |
| 5    | import copy <br />new_list = copy.copy(old_list)     | copy 활용, 깊은 복사                              |
| 6    | new_list = [i for i in old_list]                     | 리스트함축, 깊은 복사                             |
| 7    | import copy <br />new_list = copy.deepcopy(old_list) | 리스트 원소까지도 깊은 복사, 가장 느림, 깊은 복사 |

### 연결 리스트

- 리스트의 단점을 보완한 자료 구조
  1. 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조를 이룸
  2. 링크를 통해 원소에 접근하므로, 순차 리스트에서 물리적인 순서를 맞추기 위한 작업이 필요하지 않음
  3. 자료구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적인 사용이 가능
  4. 탐색 - 순차탐색

### 노드

- 연결 리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
  - 데이터 필드 : 원소의 값을 저장하는 자료구조
  - 링크 필드 : 다음 노드의 주소를 저장하는 자료구조

### 헤드

- 리스트의 처음 노드를 가리키는 레퍼런스

# 02 삽입 정렬

- 도서관 사서가 책을 정렬할 때, 일반적으로 활용되는 방식
- 자료 배열의 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아냄으로써 정렬을 완성

### 삽입 정렬의 정렬 과정

- 정렬할 자료를 두 개의 부분집합 S와 U로 가정
  - 부분집합 S : 정렬된 앞부분의 원소들
  - 부분집합 U : 아직 정렬되지 않은 나머지 원소들
- 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입
- 삽입 정렬을 반복하면서 부분집합 S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 감소하게 함
- 부분집합 U가 공집합이 되면 삽입정렬이 완성됨

# 03 병합 정렬

- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 분할 정복 알고리즘 활용
  - 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
  - Top - Down 방식

# 04 Linked List의 활용

### 스택의 원소 : 리스트의 노드

- 스택 내의 순서는 리스트의 링크를 통해 연결됨
- Push : 리스트의 마지막에 노드 삽입
- Pop : 리스트의 마지막 노드 반환 / 삭제

### 변수 Top

- 리스트의 마지막 노드를 가리키는 변수
- 초기 상태 : Top = None

### 순차 리스트를 이용한 우선순위 큐 구현

- 순차 리스트를 이용하여 자료 저장
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
- 가장 앞에 최고 우선순위의 원소가 위치하게 됨
- 문제점
  - 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함. 이에 소요되는 시간이나 메모리 낭비가 큼

### 연결리스트를 이용한 우선순위 Queue 구현

- 연결 리스트를 이용하여 자료 저장
- 원소를 삽입하는 과정에서 리스트 내 노드의 원소들과 비교하여 적절한 위치에 노드를 삽입하는 구조
- 리스트의 가장 앞쪽에 최고 우선순위가 위치하게 됨
- 배열 대비 장점
  - 삽입/삭제 연산 이후 원소의 재배치가 필요 없음
  - 메모리의 효율적인 사용이 가능함





