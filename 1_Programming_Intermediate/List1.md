# 01 알고리즘

## 알고리즘

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

### 알고리즘 표현법

1. 슈도코드
   - 일반적인 언어로 코드를 흉내 내어 알고리즘을 써 놓은 코드
2. 순서도
   - 프로그램이나 작업의 진행 흐름을 순서에 따라 여러 가지 기호나 문자로 나타낸 도표

## 무엇이 좋은 알고리즘인가?

1. 정확성
2. 작업량
3. 메모리 사용량
4. 단순성
5. 최적성

### 알고리즘의 성능 분석

- 시간 복잡도 표현하는 것 중에는 '빅-오(O) 표기법' 이 있음

## 빅-오(O) 표기법

- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수(Coefficient)는 생략하여 표시

# 02 List

### 파이썬(Python)

- 1991년 귀도 반 로섬이 개발한 프로그래밍 언어
- 인터프리어 언어로 독립적인 플랫폼
- 객체지향
- loT분야의 라즈베리파이, 최근 빅데이터의 자료분석 등에서 파이썬의 관심이 높아짐
- 파이썬이 느려서 과거엔 관심을 못받았지만 현재는 하드웨어의 성능 개선으로 실행 속도의 차이가 크지않음. 따라서 개발자들이 많이 사용함
- 하나의 변수에 다른 타입의 값을 변수에 저장할 수 있음

----

## 배열(List) 

- 같은 타입 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- 리스트를 사용하면 하나의 변수를 통해서 대량의 데이터를 효율적으로 처리할 수 있음!

|        | 배열                          | 리스트                         |
| ------ | ----------------------------- | ------------------------------ |
| 데이터 | 같은 타입의 데이터만 저장     | 다양한 데이터를 저장할 수 있음 |
| 크기   | 처음 지정한 후 변경할 수 없음 | 가변적으로 변경할 수 있음      |

- 배열보다 리스트가 사용하기 편리함

### 리스트는 시퀀스(Sequence) 자료형

- 순서가 존재함으로, 인덱싱과 슬라이싱의 연산 모두 적용가능

# 03 Exhaustive Search

- 완전검색(Exhaustive Search)
  - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
    1. Brute-force 혹은 Generate-and-Test 기법이라고도 불림
    2. 모든 경우의 수를 테스트한 후, 최종 해법을 도출함
    3. 일반적으로 경우의 수가 상대적으로 작을 때 유용함
    4. 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
    5. 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함

- 순열(Permutation)
  - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

# 04 Greedy Algorithm

- 탐욕 알고리즘(Greedy Algorithm)
  - 최적 해를 구하는데 사용되는 근시안적인 방법

# 05 Sort

- 정렬(Sort)
  - 버블 정렬
  - 카운팅 정렬
  - 선택 정렬
  - 퀵 정렬
  - 삽입 정렬
  - 병합 정렬

- 버블 정렬 : 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 카운팅 정렬 : 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

| 알고리즘    | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고                                              |
| ----------- | ------------- | ------------- | ------------- | ------------------------------------------------- |
| 버블정렬    | O(n**2)       | O(n**2)       | 비교와 교환   | 코딩이 가장 손쉬움                                |
| 카운팅 정렬 | O(n+k)        | O(n+k)        | 비교환 방식   | n이 비교적 작을 때만 가능                         |
| 선택 정렬   | O(n**2)       | O(n**2)       | 비교와 교환   | 교환의 회수가 버블, 삽입정렬보다 작음             |
| 퀵 정렬     | O(n log n)    | O(n**2)       | 분할 정복     | 최악의 경우 O(n**2)이지만, 평균적으로는 가장 빠름 |
| 삽입 정렬   | O(n**2)       | O(n**2)       | 비교와 교환   | n의 개수가 작을 때 효과적                         |
| 병합 정렬   | O(n log n)    | O(n log n)    | 분할 정복     | 연결 리스트의 경우 가장 효율적인 방식             |
